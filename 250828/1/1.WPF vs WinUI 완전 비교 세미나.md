# WPF vs WinUI 완전 비교 세미나

## 📋 목차

1. [기술 개요 및 배경](#기술-개요-및-배경)
2. [아키텍처 및 성능 비교](#아키텍처-및-성능-비교)
3. [공통 컨트롤의 주요 차이점](#공통-컨트롤의-주요-차이점)
4. [WinUI 전용 컨트롤](#winui-전용-컨트롤)
5. [터치 및 입력 지원](#터치-및-입력-지원)
6. [개발 환경 및 생태계](#개발-환경-및-생태계)
7. [크로스플랫폼 확장성 (Uno Platform)](#크로스플랫폼-확장성-uno-platform)
8. [마이그레이션 고려사항](#마이그레이션-고려사항)

## 기술 개요 및 배경

### WPF (Windows Presentation Foundation)

* **출시**: 2006년 (.NET Framework 3.0)
* **기반**: .NET Framework → .NET Core/.NET 5+
* **타겟**: Windows 데스크톱 애플리케이션
* **성숙도**: 17년간 발전된 안정적 기술

### WinUI (Windows UI Library)

* **WinUI 2**: UWP 앱용 (2019년 4월)
* **WinUI 3**: 독립적 프레임워크 (2021년)
* **기반**: Windows App SDK
* **타겟**: 현대적 Windows 애플리케이션

---

## 아키텍처 및 성능 비교

| 항목          | WPF                         | WinUI 3                      |
| ----------- | --------------------------- | ---------------------------- |
| **렌더링**     | DirectX (Software Fallback) | DirectX 12, Hardware 가속      |
| **메모리 사용량** | ~100MB (동일 기능 기준)           | ~45MB (Native AOT 적용 시)      |
| **시작 시간**   | 빠름                          | 빠름 ~ 매우 빠름 (Native AOT 적용 시) |
| **바인딩 성능**  | Binding (런타임 리플렉션)          | x:Bind (컴파일타임) + Binding 혼용  |
| **스레딩**     | Dispatcher 기반               | DispatcherQueue 기반           |
| **터치 지원**   | 기본적 터치 이벤트                  | 네이티브 터치/제스처 최적화              |

---

## 공통 컨트롤의 주요 차이점

### 🔸 StackPanel

**WPF**

```xml
<!-- 테두리/배경 적용하려면 Border로 감싸야 함 -->
<Border Background="LightBlue"
        CornerRadius="8"
        BorderBrush="DarkBlue"
        BorderThickness="2"
        Padding="15">
    <StackPanel Orientation="Vertical">
        <Button Content="Button 1" Margin="0,0,0,10"/>
        <Button Content="Button 2" Margin="0,0,0,10"/>
        <Button Content="Button 3"/>
    </StackPanel>
</Border>
```

**WinUI**

```xml
<StackPanel Orientation="Vertical" 
            Spacing="10"
            Background="LightBlue"
            CornerRadius="8"
            BorderBrush="DarkBlue"
            BorderThickness="2"
            Padding="15">
    <Button Content="Button 1"/>
    <Button Content="Button 2"/>
    <Button Content="Button 3"/>
</StackPanel>
```

✅ **WinUI 장점**:

* `Spacing` 속성으로 간격 설정이 간편

* `CornerRadius`, `BorderBrush`, `BorderThickness` 직접 지원 (Border 래퍼 불필요)
  
  * Grid, Frame 등 Panel이라면 모두 지원함

### 🔸 Button

**WPF**

```xml
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <!-- 기본 정렬: Stretch -->
    <Button Grid.Column="0" Content="Left"/>
    <Button Grid.Column="1" Content="Right"/>
</Grid>
```

**WinUI**

```xml
<Grid Background="LightGray"
      CornerRadius="12"
      BorderBrush="Gray"
      BorderThickness="1">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <!-- 기본 정렬: Left, Top이므로 HorizontalAlignment만 Stretch 설정 -->
    <Button Grid.Column="0" Content="Left" 
            HorizontalAlignment="Stretch"/>
    <Button Grid.Column="1" Content="Right" 
            HorizontalAlignment="Stretch"/>
</Grid>
```

⚠️ **WinUI 차이점**: 기본 정렬이 Left/Top이므로 명시적 설정 필요

### 🔸 Button

**WPF**

```xml
<Button Content="Click Me" 
        Background="Blue" 
        Foreground="White"/>
```

**WinUI**

```xml
<Button Content="Click Me" 
        Background="Blue" 
        Foreground="White"
        HorizontalAlignment="Stretch"/>
```

✅ **공통점**: 기본적인 속성 설정 방식은 동일
✅ **WinUI 장점**: 더 풍부한 테마 시스템 - `{ThemeResource AccentButtonBackground}` 등으로 다크/라이트 테마 자동 대응

### 🔸 ListView/ListBox

**WPF**

```xml
<ListBox ItemsSource="{Binding Items}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <TextBlock Text="{Binding Name}"/>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

**WinUI**

```xml
<ListView ItemsSource="{x:Bind Items}">
    <ListView.ItemTemplate>
        <DataTemplate x:DataType="local:ItemModel">
            <TextBlock Text="{x:Bind Name}"/>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

✅ **WinUI 장점**: `x:Bind`로 컴파일타임 바인딩, UI 가상화 성능 향상

### x:Bind vs Binding 성능 비교

| 항목               | WPF Binding | WinUI Binding | WinUI x:Bind |
| ---------------- | ----------- | ------------- | ------------ |
| **컴파일 시점**       | 런타임         | 런타임           | 컴파일타임        |
| **타입 안정성**       | ❌           | ❌             | ✅            |
| **성능**           | 기준          | 동일            | 3-5배 빠름      |
| **IntelliSense** | 제한적         | 제한적           | 완전 지원        |
| **디버깅**          | 어려움         | 어려움           | 컴파일 에러       |

```xml
<!-- WPF/WinUI 전통적 바인딩 -->
<TextBlock Text="{Binding UserName}"/>
<ListView ItemsSource="{Binding Items}"/>

<!-- WinUI x:Bind (권장) -->
<TextBlock Text="{x:Bind ViewModel.UserName}"/>
<ListView ItemsSource="{x:Bind ViewModel.Items}">
    <ListView.ItemTemplate>
        <DataTemplate x:DataType="local:ItemModel">
            <TextBlock Text="{x:Bind Title}"/>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

---

## WinUI 전용 컨트롤

### 🆕 NavigationView

```xml
<NavigationView>
    <NavigationView.MenuItems>
        <NavigationViewItem Icon="Home" Content="Home"/>
        <NavigationViewItem Icon="Settings" Content="Settings"/>
    </NavigationView.MenuItems>
    <Frame x:Name="ContentFrame"/>
</NavigationView>
```

* 햄버거 메뉴 스타일 네비게이션
* 반응형 디자인 자동 지원

### 🆕 TeachingTip

```xml
<TeachingTip x:Name="MyTeachingTip"
             Title="새 기능!"
             Subtitle="이 기능을 사용해보세요."
             Target="{x:Bind MyButton}"/>
```

* 사용자 온보딩용 툴팁
* 위치 자동 조정

### 🆕 InfoBar

```xml
<InfoBar IsOpen="True"
         Severity="Success"
         Title="성공"
         Message="작업이 완료되었습니다."/>
```

* 시스템 알림 스타일 메시지 표시

### 🆕 Expander

```xml
<Expander Header="고급 설정">
    <StackPanel>
        <CheckBox Content="옵션 1"/>
        <CheckBox Content="옵션 2"/>
    </StackPanel>
</Expander>
```

* 접을 수 있는 컨테이너

### 🆕 NumberBox

```xml
<NumberBox Value="10"
           Minimum="0"
           Maximum="100"
           SpinButtonPlacementMode="Inline"/>
```

* 숫자 입력 전용 컨트롤

### 🆕 ProgressRing

```xml
<ProgressRing IsActive="True" Width="50" Height="50"/>
```

* 원형 로딩 인디케이터

### 🆕 SwipeControl

```xml
<ListView x:Name="lv" Width="400" Height="300" Margin="12">
    <ListView.Resources>
        <FontIconSource x:Key="ReplyAllIcon" Glyph="\&#xE8C2;"/>
        <FontIconSource x:Key="ReadIcon" Glyph="\&#xE8C3;"/>
        <FontIconSource x:Key="DeleteIcon" Glyph="\&#xE74D;"/>
        <SwipeItems x:Key="left" Mode="Reveal">
            <SwipeItem Text="Reply All" IconSource="{StaticResource ReplyAllIcon}"
                       Background="#FF3e6fa7" Foreground="White"/>
            <SwipeItem Text="Open" IconSource="{StaticResource ReadIcon}"
                       Background="#FFff9501" Foreground="White"/>
        </SwipeItems>
        <SwipeItems x:Key="right" Mode="Execute">
            <SwipeItem Text="Delete" IconSource="{StaticResource DeleteIcon}"
                       Background="#FFF4B183" Invoked="DeleteItem\_ItemInvoked"/>
        </SwipeItems>
    </ListView.Resources>
    <ListView.ItemTemplate>
        <DataTemplate>
            <SwipeControl BorderThickness="0,1,0,0" BorderBrush="{ThemeResource ButtonBackground}" 
                          Height="68" Width="800" MinWidth="200" 
                          LeftItems="{StaticResource left}" RightItems="{StaticResource right}">
                <TextBlock Text="{Binding}" FontSize="24" Margin="12"
                           HorizontalAlignment="Stretch" VerticalAlignment="Center"/>
            </SwipeControl>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

* 모바일 스타일 스와이프 제스처 지원
* `Mode="Reveal"` (스와이프 유지) vs `Mode="Execute"` (즉시 실행)

### 🆕 RefreshContainer

```xml
<RefreshContainer RefreshRequested="OnRefreshRequested">
    <ListView ItemsSource="{x:Bind Items}"/>
</RefreshContainer>
```

* Pull-to-refresh 제스처 지원

---

## 터치 및 입력 지원

### WPF vs WinUI 터치 지원 비교

| 기능                  | WPF                 | WinUI 3                         |
| ------------------- | ------------------- | ------------------------------- |
| **기본 터치**           | Touch 이벤트           | 네이티브 터치 최적화                     |
| **제스처**             | Manipulation 이벤트    | 내장 제스처 컨트롤 및 이벤트                |
| **스크롤**             | ScrollViewer        | 터치 최적화된 ScrollViewer            |
| **줌/팬**             | 수동 구현 필요            | ScrollViewer.ZoomMode="Enabled" |
| **스와이프**            | 커스텀 구현 / 써드파티 라이브러리 | SwipeControl 내장                 |
| **Pull-to-refresh** | 커스텀 구현 / 써드파티 라이브러리 | RefreshContainer 내장             |

### WinUI 터치 최적화 예시

```xml
<!-- 터치 최적화된 스크롤뷰 -->
<ScrollViewer ZoomMode="Enabled" 
              HorizontalScrollMode="Auto"
              VerticalScrollMode="Auto"
              HorizontalScrollBarVisibility="Auto"
              VerticalScrollBarVisibility="Auto">
    <Image Source="large\_image.jpg"/>
</ScrollViewer>

<!-- 터치 친화적 리스트 -->
<ListView x:Name="lv" Width="400" Height="300" Margin="12">
    <ListView.Resources>
        <FontIconSource x:Key="ReplyAllIcon" Glyph="\&#xE8C2;"/>
        <FontIconSource x:Key="ReadIcon" Glyph="\&#xE8C3;"/>
        <FontIconSource x:Key="DeleteIcon" Glyph="\&#xE74D;"/>
        <SwipeItems x:Key="left" Mode="Reveal">
            <SwipeItem Text="Reply All" IconSource="{StaticResource ReplyAllIcon}"
                       Background="#FF3e6fa7" Foreground="White"/>
            <SwipeItem Text="Open" IconSource="{StaticResource ReadIcon}"
                       Background="#FFff9501" Foreground="White"/>
        </SwipeItems>
        <SwipeItems x:Key="right" Mode="Execute">
            <SwipeItem Text="Delete" IconSource="{StaticResource DeleteIcon}"
                       Background="#FFF4B183" Invoked="DeleteItem\_ItemInvoked"/>
        </SwipeItems>
    </ListView.Resources>
    <ListView.ItemTemplate>
        <DataTemplate>
            <SwipeControl BorderThickness="0,1,0,0" BorderBrush="{ThemeResource ButtonBackground}" 
                          Height="68" Width="800" MinWidth="200" 
                          LeftItems="{StaticResource left}" RightItems="{StaticResource right}">
                <TextBlock Text="{Binding}" FontSize="24" Margin="12"
                           HorizontalAlignment="Stretch" VerticalAlignment="Center"/>
            </SwipeControl>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

### 터치패드 제스처 지원

* **핀치-투-줌**: ScrollViewer에서 자동 지원
* **스와이프**: SwipeControl에서 자동 지원
* **Pull-to-refresh**: RefreshContainer에서 자동 지원
* **관성 스크롤**: 매우 자연스러운 관성 스크롤 지원

---

## 개발 환경 및 생태계

### 프로젝트 설정

**WPF**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
  </PropertyGroup>
</Project>
```

**WinUI 3**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows10.0.19041.0</TargetFramework>
    <UseWinUI>true</UseWinUI>
  </PropertyGroup>
  <PackageReference Include="Microsoft.WindowsAppSDK" Version="1.4.x"/>
</Project>
```

### 패키징 및 배포

| 항목                  | WPF                 | WinUI 3               |
| ------------------- | ------------------- | --------------------- |
| **Standalone 배포**   | ✅ Self-contained 지원 | ✅ Unpackaged 배포 지원    |
| **런타임 의존성**         | .NET Runtime 필요     | Windows App SDK 번들 가능 |
| **Native AOT**      | ❌ 지원 안함             | ✅ 지원함                 |
| **ClickOnce**       | ✅ 완전 지원             | ⚠️ 제한적                |
| **MSIX**            | ✅ 지원함               | ✅ 권장 방식               |
| **Microsoft Store** | ❌ 직접 불가             | ✅ 네이티브 지원             |

### WinUI 3 Unpackaged 배포 장점

```xml
<!-- 프로젝트 파일 설정 -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <UseWinUI>true</UseWinUI>
    <WindowsPackageType>None</WindowsPackageType>
    <WindowsAppSDKSelfContained>true</WindowsAppSDKSelfContained>
    <PublishAot>true</PublishAot>
    <SelfContained>true</SelfContained>
  </PropertyGroup>
</Project>
```

**Native AOT 적용 시 장점:**

* 시작 시간 대폭 단축
* 메모리 사용량 30-40% 감소
* 런타임 없이 단일 실행 파일 배포 가능

**배포 용량 고려사항:**

* Self-contained 빌드 시 기본 용량: ~100MB
* 7z 등 고효율 압축 적용 시: ~30MB로 압축 가능
* WPF Self-contained 대비 약간 큰 편이지만 성능상 이득이 큼

---

---

## 크로스플랫폼 확장성 (Uno Platform)

### Uno Platform 개요

Uno Platform은 WinUI 3 XAML과 C# 코드를 다양한 플랫폼에서 실행할 수 있게 해주는 오픈소스 프레임워크임.

### 지원 플랫폼 및 기술 스택

| 플랫폼         | 렌더링 기술               | 배포 방식                                             |
| ----------- | -------------------- | ------------------------------------------------- |
| **Windows** | WinUI 3 Native       | MSIX (UWP Packaged), Win32 (Unpackaged)           |
| **iOS**     | Skia + UIKit         | App Store (.ipa)      |
| **Android** | Skia + Android Views | Google Play (.aab, .apk)                          |
| **macOS**   | Skia + AppKit        | App Store, Package(.app, .dmg, .pkg)              |
| **Linux**   | Skia + GTK           | Snap Package                                      |
| **Web**     | Skia + WebAssembly   | 웹 브라우저 (WASM 기반, Brotli 적용 시 최초 다운로드 리소스 10mb 내외) |

### Skia 렌더러의 혁신

```xml
// 동일한 코드가 모든 플랫폼에서 Pixel-Perfect하게 렌더링
<Canvas Background="LightBlue">
    <Path Fill="Red" 
          Data="M 10,30 A 20,20 0,0,1 50,30 A 20,20 0,0,1 90,30 Q 90,60 50,90 Q 10,60 10,30 z"/>
    <TextBlock Text="❤️ Uno Platform" 
               FontSize="16" 
               Canvas.Left="20" 
               Canvas.Top="40"/>
</Canvas>
```

**Skia 렌더러 장점:**

* **Pixel-Perfect**: 모든 플랫폼에서 동일한 시각적 결과
* **고성능**: GPU 가속

### 현재 제약사항과 해결 현황

#### ⚠️ 진행 중인 이슈들

**IME (Input Method Editor) 지원**

* **문제**: 한글, 일본어, 중국어 등 복합 문자 입력 불완전
* **영향**: 아시아 언어권 사용자 경험 제약

## 마이그레이션 고려사항

### ✅ 마이그레이션이 수월한 경우

* 단순한 CRUD 애플리케이션
* MVVM 패턴 사용
* 표준 컨트롤 위주 사용

### ⚠️ 마이그레이션이 복잡한 경우

* 커스텀 컨트롤 다수 사용
* 타사 라이브러리 의존성 높음

### 주요 변경사항

```csharp
// WPF - 단일 Dispatcher 기반
Dispatcher.Invoke(() => {
    textBlock.Text = "UI 업데이트";
});

// 비동기 방식
await Dispatcher.InvokeAsync(() => {
    textBlock.Text = "비동기 UI 업데이트";
});

// 우선순위 설정 (복잡함)
Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action(() => {
    // 백그라운드 우선순위 작업
}));

// WinUI 3
DispatcherQueue.TryEnqueue(() => {
    // UI 업데이트
});

// WinUI 3 - DispatcherQueue 기반 (더 단순하고 효율적)
DispatcherQueue.TryEnqueue(() => {
    textBlock.Text = "UI 업데이트";
});

// 우선순위 설정 (간단함)
DispatcherQueue.TryEnqueue(DispatcherQueuePriority.High, () => {
    textBlock.Text = "높은 우선순위 UI 업데이트";
});

// 여러 DispatcherQueue 동시 활용 가능
var backgroundQueue = DispatcherQueue.GetForCurrentThread();
backgroundQueue.TryEnqueue(DispatcherQueuePriority.Low, () => {
    // 백그라운드 작업
});
```
